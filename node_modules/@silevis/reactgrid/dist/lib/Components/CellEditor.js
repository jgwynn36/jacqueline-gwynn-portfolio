import * as React from 'react';
import { tryAppendChange } from '../Functions';
export var CellEditor = function (props) {
    var location = props.state.focusedLocation;
    var _a = React.useState(calculatedEditorPosition(location, props.state)), position = _a[0], setPosition = _a[1];
    React.useEffect(function () { return setPosition(calculatedEditorPosition(location, props.state)); }, []);
    var cellTemplate = props.state.cellTemplates[props.state.currentlyEditedCell.type];
    return (React.createElement("div", { className: "rg-celleditor rg-" + props.state.currentlyEditedCell.type + "-celleditor", style: {
            top: position.top + (props.state.disableFloatingCellEditor ? 0 : -1),
            left: position.left + (props.state.disableFloatingCellEditor ? 0 : -1),
            height: location.row.height + 1,
            width: location.column.width + 1,
            position: props.state.disableFloatingCellEditor ? 'absolute' : 'fixed',
        } }, cellTemplate.render(props.state.currentlyEditedCell, true, function (cell, commit) {
        props.state.currentlyEditedCell = commit ? undefined : cell;
        if (commit)
            props.state.update(function (state) { return tryAppendChange(state, location, cell); });
    })));
};
var calculatedXAxisOffset = function (location, state) {
    var offsetLeftDistance = state.disableFloatingCellEditor ? state.viewportElement.scrollLeft - 1 : state.viewportElement.offsetLeft;
    if (state.cellMatrix.frozenRightRange.first.column && location.column.idx >= state.cellMatrix.frozenRightRange.first.column.idx) {
        return Math.min(state.cellMatrix.width, state.viewportElement.clientWidth) - state.cellMatrix.frozenRightRange.width + offsetLeftDistance;
    }
    else if (location.column.idx > (state.cellMatrix.frozenLeftRange.last.column ? state.cellMatrix.frozenLeftRange.last.column.idx : state.cellMatrix.first.column.idx) || location.column.idx == state.cellMatrix.last.column.idx) {
        return state.cellMatrix.frozenLeftRange.width - state.viewportElement.scrollLeft + offsetLeftDistance;
    }
    return offsetLeftDistance;
};
var calculatedYAxisOffset = function (location, state) {
    var isViewportScrollable = state.viewportElement.clientHeight !== state.cellMatrix.height;
    var topOffsetDistance = state.disableFloatingCellEditor ? state.viewportElement.scrollTop - 1 : state.viewportElement.getBoundingClientRect().top;
    if (state.cellMatrix.frozenBottomRange.first.row && location.row.idx >= state.cellMatrix.frozenBottomRange.first.row.idx) {
        var res = topOffsetDistance - state.cellMatrix.frozenBottomRange.height + state.viewportElement.clientHeight;
        return res;
    }
    else if (location.row.idx > (state.cellMatrix.frozenTopRange.last.row ? state.cellMatrix.frozenTopRange.last.row.idx : state.cellMatrix.first.row.idx) || location.row.idx == state.cellMatrix.last.row.idx) {
        return topOffsetDistance + state.cellMatrix.frozenTopRange.height - state.viewportElement.scrollTop;
    }
    return topOffsetDistance;
};
var calculatedEditorPosition = function (location, state) {
    return {
        left: location.column.left + calculatedXAxisOffset(location, state),
        top: location.row.top + calculatedYAxisOffset(location, state)
    };
};
